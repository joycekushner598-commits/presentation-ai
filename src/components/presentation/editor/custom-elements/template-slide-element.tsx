"use client";

import { generateImageAction } from "@/app/_actions/image/generate";
import { slideTemplates } from "@/lib/presentation/templates";
import { PlateElement, withRef, useEditorRef } from "platejs/react";
import { useEffect, useRef, useState } from "react";
import { toast } from "sonner";
import { ScaledTemplateRenderer } from "../../template/TemplateRenderer";
import { type TTemplateSlideElement } from "../plugins/template-slide-plugin";

/**
 * 模板幻灯片元素渲染组件
 * 
 * 当 AI 生成 <TEMPLATE-SLIDE> 标签时，这个组件会被使用
 * 自动为所有图片槽位生成图片
 */
export const TemplateSlideElement = withRef<typeof PlateElement>(
    ({ element, children, className, ...props }, ref) => {
        const templateElement = element as unknown as TTemplateSlideElement;
        const { templateId, content, images } = templateElement;
        const containerRef = useRef<HTMLDivElement>(null);
        const [width, setWidth] = useState(800);
        const [isGenerating, setIsGenerating] = useState(false);
        const [generatingSlots, setGeneratingSlots] = useState<Set<string>>(new Set());
        const editor = useEditorRef();
        const hasAutoGeneratedRef = useRef(false);

        // 获取模板配置
        const template = slideTemplates[templateId];

        // 监听容器宽度变化
        useEffect(() => {
            if (!containerRef.current) return;

            const observer = new ResizeObserver((entries) => {
                for (const entry of entries) {
                    if (entry.contentRect.width > 0) {
                        setWidth(entry.contentRect.width);
                    }
                }
            });

            observer.observe(containerRef.current);
            return () => observer.disconnect();
        }, []);

        // 检查 URL 是否是有效的图片 URL
        const isValidImageUrl = (url: string | undefined): boolean => {
            if (!url) return false;
            return url.startsWith("http") || url.startsWith("/") || url.startsWith("data:");
        };

        // 自动生成所有缺失的图片
        useEffect(() => {
            if (!template || hasAutoGeneratedRef.current) return;

            // 找出所有需要生成图片的槽位
            const slotsToGenerate: { slotId: string; query: string }[] = [];

            for (const el of template.elements) {
                if (el.type === "image" || (el.type === "background" && el.imageQuery)) {
                    const slotId = el.slot || el.id;
                    const existingUrl = images?.[slotId];
                    const query = images?.[slotId] || el.imageQuery;

                    // 如果没有有效 URL 且有查询词，需要生成
                    if (!isValidImageUrl(existingUrl) && query) {
                        slotsToGenerate.push({ slotId, query });
                    }
                }
            }

            if (slotsToGenerate.length === 0) return;

            hasAutoGeneratedRef.current = true;

            // 异步生成所有图片
            const generateAllImages = async () => {
                setIsGenerating(true);
                const toastId = toast.loading(`Generating ${slotsToGenerate.length} image(s)...`);

                const newImages = { ...images };
                let successCount = 0;

                for (const { slotId, query } of slotsToGenerate) {
                    setGeneratingSlots(prev => new Set(prev).add(slotId));

                    try {
                        console.log(`[AutoGen] Generating image for ${slotId}: ${query}`);
                        const result = await generateImageAction(query, "nano-banana-pro-preview");

                        if (result.success && result.image?.url) {
                            newImages[slotId] = result.image.url;
                            successCount++;
                            console.log(`[AutoGen] Success for ${slotId}`);
                        } else {
                            console.warn(`[AutoGen] Failed for ${slotId}:`, result.error);
                        }
                    } catch (error) {
                        console.error(`[AutoGen] Error for ${slotId}:`, error);
                    }

                    setGeneratingSlots(prev => {
                        const next = new Set(prev);
                        next.delete(slotId);
                        return next;
                    });
                }

                // 更新所有图片
                if (successCount > 0) {
                    editor.tf.setNodes<TTemplateSlideElement>({
                        images: newImages,
                    });
                    toast.success(`Generated ${successCount}/${slotsToGenerate.length} images!`, { id: toastId });
                } else {
                    toast.error("Failed to generate images", { id: toastId });
                }

                setIsGenerating(false);
            };

            generateAllImages();
        }, [template, images, editor]);

        // 处理图片点击生成（手动重新生成）
        const handleImageClick = async (slotId: string, query: string) => {
            if (isGenerating) {
                toast.error("Already generating images. Please wait.");
                return;
            }

            const confirmGen = window.confirm(`Regenerate image for "${query}"?`);
            if (!confirmGen) return;

            setIsGenerating(true);
            const toastId = toast.loading(`Generating image: ${query}...`);

            try {
                const result = await generateImageAction(query, "nano-banana-pro-preview");

                if (result.success && result.image?.url) {
                    const newImages = { ...images, [slotId]: result.image.url };
                    editor.tf.setNodes<TTemplateSlideElement>({
                        images: newImages,
                    });
                    toast.success("Image generated successfully!", { id: toastId });
                } else {
                    toast.error(`Generation failed: ${result.error}`, { id: toastId });
                }
            } catch (error) {
                console.error("Image generation error:", error);
                toast.error("Failed to generate image", { id: toastId });
            } finally {
                setIsGenerating(false);
            }
        };

        if (!template) {
            return (
                <PlateElement ref={ref} element={element} className={className} {...props}>
                    <div className="p-4 text-red-500">
                        模板未找到: {templateId}
                    </div>
                    {children}
                </PlateElement>
            );
        }

        return (
            <PlateElement
                ref={ref}
                element={element}
                className={className}
                {...props}
                style={{ width: "100%", height: "100%", display: "block" }}
            >
                <div
                    ref={containerRef}
                    className="template-slide-host relative"
                    style={{ width: "100%", height: "100%", opacity: isGenerating ? 0.7 : 1, transition: 'opacity 0.2s' }}
                    contentEditable={false}
                >
                    <ScaledTemplateRenderer
                        template={template}
                        content={content ?? {}}
                        images={images ?? {}}
                        containerWidth={width}
                        onImageClick={handleImageClick}
                    />
                    {isGenerating && (
                        <div className="absolute inset-0 flex items-center justify-center bg-black/20 z-50">
                            <div className="bg-white px-6 py-4 rounded-lg shadow-lg flex flex-col items-center gap-2">
                                <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin" />
                                <span className="text-sm text-gray-700">
                                    Generating {generatingSlots.size > 0 ? `(${generatingSlots.size} remaining)` : "images"}...
                                </span>
                            </div>
                        </div>
                    )}
                </div>
                {children}
            </PlateElement>
        );
    }
);
